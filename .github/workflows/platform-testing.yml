name: Platform Testing

on:
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'docker-compose*.yml'
      - 'Makefile'
      - 'docs/Install_Local.md'
      - 'backend/**'
      - 'telegram-bot/**'
      - 'analysis/**'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      test_platform:
        description: "Platform to test"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - macos-latest
          - ubuntu-latest
          - windows-latest
      skip_services:
        description: "Skip heavy services (ML API, monitoring) for faster testing"
        required: false
        default: false
        type: boolean

# NOTE: This workflow tests the local installation process across different platforms
# It creates dummy thesaurus data to avoid SSH dependencies during testing
# The actual thesaurus data is only needed for production deployments

jobs:
  test-ubuntu:
    runs-on: ubuntu-latest
    if: github.event.inputs.test_platform == 'ubuntu-latest' || github.event.inputs.test_platform == 'all' || github.event.inputs.test_platform == ''
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Test Ubuntu installation
        run: |
          echo "Testing local installation on Ubuntu..."
          
          # Create .env files from examples (like deploy.yml does)
          echo "Creating .env files from examples..."
          if [ ! -f .env ]; then
            cp .env.example .env
            echo "Created root .env from example"
          fi
          if [ ! -f backend/.env ]; then
            cp backend/.env.example backend/.env
            echo "Created backend/.env from example"
          fi
          
          # Create dummy thesaurus data for testing (skip SSH dependency)
          echo "Creating dummy thesaurus data for testing..."
          mkdir -p analysis/thesaurus
          cat > analysis/thesaurus/result.csv << 'EOF'
          word,topic,subtopic,subsubtopic,CEFR_level,Total
          test,test_topic,test_subtopic,test_subsubtopic,a1,1
          example,example_topic,example_subtopic,example_subsubtopic,a2,1
          sample,sample_topic,sample_subtopic,sample_subsubtopic,b1,1
          EOF
          echo "Created dummy thesaurus data for testing"
          
          # Setup volumes (skip make setup-env since we already created .env files)
          make setup-volumes
          
          # Check for port conflicts
          make check-ports
          
          # Pre-build local images that need to be built from Dockerfiles
          echo "Pre-building local images for faster startup..."
          docker compose -f docker-compose-local.yml build thesaurus-api llm-api
          
          # Create minimal docker-compose override for testing
          if [ "${{ github.event.inputs.skip_services }}" = "true" ]; then
            cat > docker-compose.test.yml << 'EOF'
          version: '3.8'
          services:
            # Disable resource-intensive services for faster testing
            ml-api:
              deploy:
                replicas: 0
            prometheus:
              deploy:
                replicas: 0
            grafana:
              deploy:
                replicas: 0
            loki:
              deploy:
                replicas: 0
            promtail:
              deploy:
                replicas: 0
            cadvisor:
              deploy:
                replicas: 0
            node-exporter:
              deploy:
                replicas: 0
          EOF
            export COMPOSE_FILE="docker-compose.yml:docker-compose.test.yml"
          fi
          
          # Start services
          make run-local
          
          # Wait for services to be ready
          echo "Waiting for services to start..."
          sleep 45  # Give services more time to start
          
          # Test core endpoints (from Install_Local.md)
          echo "Testing core service endpoints..."
          
          # Backend API
          for i in {1..10}; do
            if curl -f http://localhost:8070/health > /dev/null 2>&1; then
              echo "Backend API is healthy"
              break
            elif [ $i -eq 10 ]; then
              echo "Backend API failed to start"
              exit 1
            else
              echo "Waiting for backend API... (attempt $i/10)"
              sleep 10
            fi
          done
          
          # Thesaurus API with extended timeout (built from Dockerfile)
          for i in {1..10}; do
            if curl -f -X POST http://localhost:8002/health -H "Content-Type: application/json" -d '{"ping":"test"}' > /dev/null 2>&1; then
              echo "Thesaurus API is healthy"
              break
            elif [ $i -eq 10 ]; then
              echo "Thesaurus API failed to start"
              echo "Checking thesaurus container logs..."
              docker compose logs thesaurus-api || true
              exit 1
            else
              echo "Waiting for thesaurus API... (attempt $i/10)"
              sleep 20
            fi
          done
          
          # LLM API
          for i in {1..5}; do
            if curl -f http://localhost:8003/health > /dev/null 2>&1; then
              echo "LLM API is healthy"
              break
            elif [ $i -eq 5 ]; then
              echo "LLM API failed to start"
              exit 1
            else
              echo "Waiting for LLM API... (attempt $i/5)"
              sleep 10
            fi
          done
          
          # Test ML API only if not skipped
          if [ "${{ github.event.inputs.skip_services }}" != "true" ]; then
            for i in {1..15}; do
              if curl -f http://localhost:8001/health > /dev/null 2>&1; then
                echo "ML API is healthy"
                break
              elif [ $i -eq 15 ]; then
                echo "ML API failed to start"
                exit 1
              else
                echo "Waiting for ML API... (attempt $i/15)"
                sleep 15
              fi
            done
          fi
          
          # Test Quick Start endpoints (from Install_Local.md)
          echo "Testing Quick Start endpoints..."
          
          # Test Swagger UI
          if curl -f http://localhost:8070/swagger/ > /dev/null 2>&1; then
            echo "Swagger UI is accessible at http://localhost:8070/swagger/"
          else
            echo "Swagger UI is not accessible"
            exit 1
          fi
          
          # Test Directus admin panel
          if curl -f http://localhost:8055 > /dev/null 2>&1; then
            echo "Directus admin panel is accessible at http://localhost:8055/"
          else
            echo "Directus admin panel is not accessible"
            exit 1
          fi
          
          # Test Distractor API docs
          if curl -f http://localhost:8001/docs > /dev/null 2>&1; then
            echo "Distractor API docs are accessible at http://localhost:8001/docs"
          else
            echo "Distractor API docs are not accessible (may be disabled in test)"
          fi
          
          # Test Thesaurus API docs
          if curl -f http://localhost:8002/docs > /dev/null 2>&1; then
            echo "Thesaurus API docs are accessible at http://localhost:8002/docs"
          else
            echo "Thesaurus API docs are not accessible"
            exit 1
          fi
          
          # Test LLM API docs
          if curl -f http://localhost:8003/docs > /dev/null 2>&1; then
            echo "LLM API docs are accessible at http://localhost:8003/docs"
          else
            echo "LLM API docs are not accessible"
            exit 1
          fi

      - name: Show service status
        if: always()
        run: |
          echo "Service Status:"
          make status || true
          
          echo "Docker Compose Services:"
          docker compose ps || true
          
          echo "Disk Usage:"
          df -h | head -5

      - name: Show logs on failure
        if: failure()
        run: |
          echo "Service Logs:"
          docker compose logs --tail=50 || true

      - name: Cleanup
        if: always()
        run: |
          make stop-local || true
          docker system prune -f || true

  test-windows:
    runs-on: windows-latest
    if: github.event.inputs.test_platform == 'windows-latest' || github.event.inputs.test_platform == 'all' || github.event.inputs.test_platform == ''
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Desktop
        run: |
          # Set encoding to UTF-8 for console output
          [Console]::OutputEncoding = [Text.Encoding]::UTF8
          
          Write-Host "Setting up Docker for Windows..."
          
          # Check if Docker is already available (GitHub runners sometimes have it)
          try {
            docker version | Out-Null
            docker info | Out-Null
            Write-Host "Docker is already running and ready!"
            docker info | Select-String -Pattern "(Server Version|Operating System|Architecture|CPUs|Total Memory)"
            exit 0
          } catch {
            Write-Host "Docker not available, installing Docker Desktop..."
          }
          
          # Install Chocolatey if not available
          if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
            Write-Host "Installing Chocolatey..."
            Set-ExecutionPolicy Bypass -Scope Process -Force
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
            iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
          }
          
          # Install Docker Desktop
          Write-Host "Installing Docker Desktop..."
          choco install docker-desktop -y --no-progress
          
          # Start Docker Desktop
          Write-Host "Starting Docker Desktop..."
          $dockerPath = "C:\Program Files\Docker\Docker\Docker Desktop.exe"
          if (Test-Path $dockerPath) {
            Start-Process $dockerPath -WindowStyle Hidden
          } else {
            Write-Host "Docker Desktop executable not found at expected location"
            exit 1
          }
          
          # Wait for Docker Desktop to fully initialize with more aggressive checking
          Write-Host "Waiting for Docker Desktop to start..."
          $timeout = 900 # 15 minutes
          $elapsed = 0
          $restartCount = 0
          
          do {
            Start-Sleep -Seconds 10
            $elapsed += 10
            
            try {
              # Try multiple ways to detect if Docker is ready
              $version = docker version --format json 2>$null
              if ($version) {
                docker info 2>$null | Out-Null
                Write-Host "Docker Desktop is ready (took $elapsed seconds)"
                break
              } else {
                Write-Host "Docker client responding, waiting for daemon... ($elapsed/$timeout seconds)"
              }
            } catch {
              Write-Host "Waiting for Docker to start... ($elapsed/$timeout seconds)"
            }
            
            # Try to restart Docker Desktop every 5 minutes
            if (($elapsed % 300) -eq 0 -and $elapsed -gt 0 -and $restartCount -lt 2) {
              Write-Host "Restarting Docker Desktop after $elapsed seconds (attempt $($restartCount + 1))..."
              Stop-Process -Name "Docker Desktop" -Force -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 5
              Start-Process $dockerPath -WindowStyle Hidden
              Start-Sleep -Seconds 30
              $restartCount++
            }
          } while ($elapsed -lt $timeout)
          
          if ($elapsed -ge $timeout) {
            Write-Host "Docker Desktop failed to start within 15 minutes"
            Write-Host "Final attempt to start Docker Desktop..."
            Stop-Process -Name "Docker Desktop" -Force -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 5
            Start-Process $dockerPath -WindowStyle Hidden
            Start-Sleep -Seconds 60
            
            # Final check
            try {
              docker info 2>$null | Out-Null
              Write-Host "Docker Desktop started after final attempt"
            } catch {
              Write-Host "Docker Desktop still not ready - this will cause test failures"
              exit 1
            }
          }
          
          # Show Docker info if available
          Write-Host "Docker Info:"
          try {
            docker info | Select-String -Pattern "(Server Version|Operating System|Architecture|CPUs|Total Memory)"
          } catch {
            Write-Host "Docker info not available"
          }
          
          # Ensure Docker Desktop is using Linux containers (required for our Linux-only images)
          Write-Host "Configuring Docker Desktop to use Linux containers..."
          try {
            # Check current container mode
            $dockerInfo = docker info 2>$null | Out-String
            if ($dockerInfo -match "OSType:\s*linux") {
              Write-Host "Docker Desktop is already using Linux containers"
            } else {
              Write-Host "Docker Desktop is using Windows containers, switching to Linux containers..."
              
              # Switch to Linux containers using Docker Desktop CLI
              $dockerCliPath = "C:\Program Files\Docker\Docker\DockerCli.exe"
              if (Test-Path $dockerCliPath) {
                & $dockerCliPath -SwitchLinuxEngine
                Start-Sleep -Seconds 30
              } else {
                Write-Host "Docker CLI not found, trying alternative method..."
                # Alternative method: restart Docker Desktop with Linux containers
                $registryPath = "HKCU:\Software\Docker Inc.\Docker Desktop"
                if (Test-Path $registryPath) {
                  Set-ItemProperty -Path $registryPath -Name "EngineType" -Value "linux"
                  Write-Host "Set Docker Desktop to use Linux containers in registry"
                }
              }
              
              # Wait for Docker to restart with Linux containers
              Write-Host "Waiting for Docker to restart with Linux containers..."
              $timeout = 120
              $elapsed = 0
              do {
                Start-Sleep -Seconds 5
                $elapsed += 5
                try {
                  $dockerInfo = docker info 2>$null | Out-String
                  if ($dockerInfo -match "OSType:\s*linux") {
                    Write-Host "Docker Desktop is now using Linux containers"
                    break
                  }
                } catch {
                  Write-Host "Waiting for Docker to restart... ($elapsed/$timeout seconds)"
                }
              } while ($elapsed -lt $timeout)
            }
            
            # Verify final state
            $dockerInfo = docker info 2>$null | Out-String
            if ($dockerInfo -match "OSType:\s*linux") {
              Write-Host "✅ Docker Desktop is configured for Linux containers"
            } else {
              Write-Host "⚠️ Warning: Docker Desktop may not be using Linux containers"
              Write-Host "This is required for Fluently project as all images are built for Linux"
            }
          } catch {
            Write-Host "Warning: Could not verify Docker container mode"
          }
        shell: powershell

      - name: Test Windows installation
        run: |
          # Set encoding to UTF-8 for console output
          [Console]::OutputEncoding = [Text.Encoding]::UTF8
          
          Write-Host "Testing local installation on Windows..."
          
          # Check system resources before starting
          Write-Host "System Resources:"
          Write-Host "Windows Version: $((Get-ComputerInfo).WindowsProductName)"
          Write-Host "Architecture: $env:PROCESSOR_ARCHITECTURE"
          Write-Host "Available RAM: $([math]::Round((Get-ComputerInfo).TotalPhysicalMemory / 1GB, 2)) GB"
          Write-Host "Free Disk Space: $([math]::Round((Get-PSDrive C).Free / 1GB, 2)) GB"
          Write-Host "CPU: $((Get-ComputerInfo).CsProcessors.Name)"
          
          # Verify Docker is working
          try {
            docker info | Out-Null
            Write-Host "Docker is working properly"
          } catch {
            Write-Host "Docker is not working properly, skipping platform test"
            exit 0
          }
          
          # Create .env files from examples (like deploy.yml does)
          Write-Host "Creating .env files from examples..."
          if (-not (Test-Path ".env")) {
            Copy-Item ".env.example" ".env"
            Write-Host "Created root .env from example"
          }
          if (-not (Test-Path "backend\.env")) {
            Copy-Item "backend\.env.example" "backend\.env"
            Write-Host "Created backend\.env from example"
          }
          
          # Create dummy thesaurus data for testing (skip SSH dependency)
          New-Item -ItemType Directory -Force -Path "analysis\thesaurus"
          @"
          word,topic,subtopic,subsubtopic,CEFR_level,Total
          test,test_topic,test_subtopic,test_subsubtopic,a1,1
          "@ | Out-File -FilePath "analysis\thesaurus\result.csv" -Encoding utf8
          Write-Host "Created dummy thesaurus data for testing"
          
          # Install Make if not available (using Chocolatey)
          if (-not (Get-Command make -ErrorAction SilentlyContinue)) {
            Write-Host "Installing Make via Chocolatey..."
            choco install make -y --no-progress
          }
          
          # Setup volumes (skip make setup-env since we already created .env files)
          make setup-volumes
          
          # Check for port conflicts
          make check-ports
          
          # Pre-build local images that need to be built from Dockerfiles
          Write-Host "Pre-building local images for faster startup..."
          docker compose -f docker-compose-local.yml build thesaurus-api llm-api
          
          # Create minimal docker-compose override for testing
          if ("${{ github.event.inputs.skip_services }}" -eq "true") {
            @"
          version: '3.8'
          services:
            # Disable resource-intensive services for faster testing
            ml-api:
              deploy:
                replicas: 0
            prometheus:
              deploy:
                replicas: 0
            grafana:
              deploy:
                replicas: 0
            loki:
              deploy:
                replicas: 0
            promtail:
              deploy:
                replicas: 0
            cadvisor:
              deploy:
                replicas: 0
            node-exporter:
              deploy:
                replicas: 0
          "@ | Out-File -FilePath "docker-compose.test.yml" -Encoding utf8
            $env:COMPOSE_FILE = "docker-compose.yml:docker-compose.test.yml"
          }
          
          # Start services
          make run-local
          
          # Wait for services to be ready
          Write-Host "Waiting for services to start..."
          Start-Sleep -Seconds 45  # Windows might need more time
          
          # Test core endpoints (from Install_Local.md)
          Write-Host "Testing core service endpoints..."
          
          # Backend API
          for ($i = 1; $i -le 10; $i++) {
            try {
              $response = Invoke-WebRequest -Uri "http://localhost:8070/health" -UseBasicParsing -TimeoutSec 5
              if ($response.StatusCode -eq 200) {
                Write-Host "Backend API is healthy"
                break
              }
            } catch {
              if ($i -eq 10) {
                Write-Host "Backend API failed to start"
                exit 1
              } else {
                Write-Host "Waiting for backend API... (attempt $i/10)"
                Start-Sleep -Seconds 10
              }
            }
          }
          
          # Thesaurus API (built from Dockerfile)
          for ($i = 1; $i -le 10; $i++) {
            try {
              $response = Invoke-WebRequest -Uri "http://localhost:8002/health" -Method Post -Body '{"ping":"test"}' -ContentType "application/json" -UseBasicParsing -TimeoutSec 10
              if ($response.StatusCode -eq 200) {
                Write-Host "Thesaurus API is healthy"
                break
              }
            } catch {
              if ($i -eq 10) {
                Write-Host "Thesaurus API failed to start"
                Write-Host "Checking thesaurus container logs..."
                docker compose logs thesaurus-api
                exit 1
              } else {
                Write-Host "Waiting for thesaurus API... (attempt $i/10)"
                Start-Sleep -Seconds 20
              }
            }
          }
          
          # LLM API (built from Dockerfile)
          for ($i = 1; $i -le 8; $i++) {
            try {
              $response = Invoke-WebRequest -Uri "http://localhost:8003/health" -UseBasicParsing -TimeoutSec 10
              if ($response.StatusCode -eq 200) {
                Write-Host "LLM API is healthy"
                break
              }
            } catch {
              if ($i -eq 8) {
                Write-Host "LLM API failed to start"
                Write-Host "Checking LLM container logs..."
                docker compose logs llm-api
                exit 1
              } else {
                Write-Host "Waiting for LLM API... (attempt $i/8)"
                Start-Sleep -Seconds 15
              }
            }
          }
          
          # Test ML API only if not skipped
          if ("${{ github.event.inputs.skip_services }}" -ne "true") {
            for ($i = 1; $i -le 15; $i++) {
              try {
                $response = Invoke-WebRequest -Uri "http://localhost:8001/health" -UseBasicParsing -TimeoutSec 5
                if ($response.StatusCode -eq 200) {
                  Write-Host "ML API is healthy"
                  break
                }
              } catch {
                if ($i -eq 15) {
                  Write-Host "ML API failed to start"
                  exit 1
                } else {
                  Write-Host "Waiting for ML API... (attempt $i/15)"
                  Start-Sleep -Seconds 15
                }
              }
            }
          }
          
          # Test Quick Start endpoints (from Install_Local.md)
          Write-Host "🎯 Testing Quick Start endpoints..."
          
          # Test Swagger UI
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:8070/swagger/" -UseBasicParsing -TimeoutSec 10
            if ($response.StatusCode -eq 200) {
              Write-Host "Swagger UI is accessible at http://localhost:8070/swagger/"
            }
          } catch {
            Write-Host "Swagger UI is not accessible"
            exit 1
          }
          
          # Test Directus admin panel
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:8055" -UseBasicParsing -TimeoutSec 10
            if ($response.StatusCode -eq 200) {
              Write-Host "Directus admin panel is accessible at http://localhost:8055/"
            }
          } catch {
            Write-Host "Directus admin panel is not accessible"
            exit 1
          }
          
          # Test Distractor API docs
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:8001/docs" -UseBasicParsing -TimeoutSec 10
            if ($response.StatusCode -eq 200) {
              Write-Host "Distractor API docs are accessible at http://localhost:8001/docs"
            }
          } catch {
            Write-Host "Distractor API docs are not accessible (may be disabled in test)"
          }
          
          # Test Thesaurus API docs
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:8002/docs" -UseBasicParsing -TimeoutSec 10
            if ($response.StatusCode -eq 200) {
              Write-Host "Thesaurus API docs are accessible at http://localhost:8002/docs"
            }
          } catch {
            Write-Host "Thesaurus API docs are not accessible"
            exit 1
          }
          
          # Test LLM API docs
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:8003/docs" -UseBasicParsing -TimeoutSec 10
            if ($response.StatusCode -eq 200) {
              Write-Host "LLM API docs are accessible at http://localhost:8003/docs"
            }
          } catch {
            Write-Host "LLM API docs are not accessible"
            exit 1
          }
        shell: powershell

      - name: Show service status
        if: always()
        run: |
          Write-Host "Service Status:"
          make status
          
          Write-Host "📋 Docker Compose Services:"
          docker compose ps
          
          Write-Host "💾 Disk Usage:"
          Get-PSDrive C | Select-Object Used,Free,@{Name="Size";Expression={$_.Used+$_.Free}}
        shell: powershell

      - name: Show logs on failure
        if: failure()
        run: |
          Write-Host "Service Logs:"
          docker compose logs --tail=50
        shell: powershell

      - name: Cleanup
        if: always()
        run: |
          make stop-local
          docker system prune -f
        shell: powershell

  test-macos:
    runs-on: macos-latest
    if: github.event.inputs.test_platform == 'macos-latest' || github.event.inputs.test_platform == 'all' || github.event.inputs.test_platform == ''
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Docker Desktop
        run: |
          echo "Setting up Docker for macOS..."
          
          # Check if Docker is already available (GitHub runners sometimes have it)
          if command -v docker &> /dev/null && docker info > /dev/null 2>&1; then
            echo "Docker is already running and ready!"
            docker info | grep -E "(Server Version|Operating System|Architecture|CPUs|Total Memory)" || true
            exit 0
          fi
          
          # Install Docker Desktop via Homebrew (more reliable than direct download)
          echo "Installing Docker Desktop via Homebrew..."
          export HOMEBREW_NO_AUTO_UPDATE=1
          export HOMEBREW_NO_INSTALL_CLEANUP=1
          
          # Install Homebrew if not available
          if ! command -v brew &> /dev/null; then
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" || true
            eval "$(/opt/homebrew/bin/brew shellenv)" || eval "$(/usr/local/bin/brew shellenv)" || true
          fi
          
          # Install Docker Desktop
          brew install --cask docker
          
          # Start Docker Desktop
          echo "Starting Docker Desktop..."
          open /Applications/Docker.app
          
          # Wait for Docker to be ready with more aggressive checking
          echo "Waiting for Docker Desktop to start..."
          timeout_minutes=15
          timeout_seconds=$((timeout_minutes * 60))
          elapsed=0
          
          while [ $elapsed -lt $timeout_seconds ]; do
            # Try multiple ways to detect if Docker is ready
            if docker version > /dev/null 2>&1 && docker info > /dev/null 2>&1; then
              echo "Docker Desktop is ready (took $elapsed seconds)"
              break
            elif docker version > /dev/null 2>&1; then
              echo "Docker client is ready, waiting for daemon... ($elapsed/$timeout_seconds seconds)"
            else
              echo "Waiting for Docker to start... ($elapsed/$timeout_seconds seconds)"
            fi
            
            sleep 10
            elapsed=$((elapsed + 10))
            
            # Try to restart Docker Desktop every 5 minutes
            if [ $((elapsed % 300)) -eq 0 ] && [ $elapsed -gt 0 ]; then
              echo "Restarting Docker Desktop after $elapsed seconds..."
              pkill -f "Docker Desktop" || true
              sleep 5
              open /Applications/Docker.app
              sleep 30
            fi
          done
          
          if [ $elapsed -ge $timeout_seconds ]; then
            echo "Docker Desktop failed to start within $timeout_minutes minutes"
            echo "Final attempt to start Docker Desktop..."
            pkill -f "Docker Desktop" || true
            sleep 5
            open /Applications/Docker.app
            sleep 60
            
            # Final check
            if docker info > /dev/null 2>&1; then
              echo "Docker Desktop started after final attempt"
            else
              echo "Docker Desktop still not ready - this will cause test failures"
              exit 1
            fi
          fi
          
          # Show Docker info
          echo "Docker Info:"
          docker info | grep -E "(Server Version|Operating System|Architecture|CPUs|Total Memory)" || true

      - name: Test macOS installation
        run: |
          echo "Testing local installation on macOS..."
          
          # Check system resources before starting
          echo "System Resources:"
          echo "macOS Version: $(sw_vers -productVersion)"
          echo "Architecture: $(uname -m)"
          echo "Available RAM: $(sysctl -n hw.memsize | awk '{print $1/1024/1024/1024 " GB"}')"
          echo "Free Disk Space: $(df -h / | tail -1 | awk '{print $4}')"
          echo "CPU Info: $(sysctl -n machdep.cpu.brand_string)"
          
          # Verify Docker is working
          if ! docker info > /dev/null 2>&1; then
            echo "Docker is not working properly, skipping platform test"
            exit 0
          fi
          
          # Create .env files from examples (like deploy.yml does)
          echo "Creating .env files from examples..."
          if [ ! -f .env ]; then
            cp .env.example .env
            echo "Created root .env from example"
          fi
          if [ ! -f backend/.env ]; then
            cp backend/.env.example backend/.env
            echo "Created backend/.env from example"
          fi
          
          # Create dummy thesaurus data for testing (skip SSH dependency)
          mkdir -p analysis/thesaurus
          echo "word,topic,subtopic,subsubtopic,CEFR_level,Total" > analysis/thesaurus/result.csv
          echo "test,test_topic,test_subtopic,test_subsubtopic,a1,1" >> analysis/thesaurus/result.csv
          echo "Created dummy thesaurus data for testing"
          
          # Check if Make is available
          if ! command -v make &> /dev/null; then
            echo "Installing Make via Homebrew..."
            brew install make
          fi
          
          # Setup volumes (skip make setup-env since we already created .env files)
          make setup-volumes
          
          # Check for port conflicts
          make check-ports
          
          # Pre-build local images that need to be built from Dockerfiles
          echo "Pre-building local images for faster startup..."
          docker compose -f docker-compose-local.yml build thesaurus-api llm-api
          
          # Create minimal docker-compose override for testing
          if [ "${{ github.event.inputs.skip_services }}" = "true" ]; then
            cat > docker-compose.test.yml << 'EOF'
          version: '3.8'
          services:
            # Disable resource-intensive services for faster testing
            ml-api:
              deploy:
                replicas: 0
            prometheus:
              deploy:
                replicas: 0
            grafana:
              deploy:
                replicas: 0
            loki:
              deploy:
                replicas: 0
            promtail:
              deploy:
                replicas: 0
            cadvisor:
              deploy:
                replicas: 0
            node-exporter:
              deploy:
                replicas: 0
          EOF
            export COMPOSE_FILE="docker-compose.yml:docker-compose.test.yml"
          fi
          
          # Start services
          make run-local
          
          # Wait for services to be ready
          echo "Waiting for services to start..."
          sleep 45  # macOS might need a bit more time
          
          # Test core endpoints (from Install_Local.md)
          echo "Testing core service endpoints..."
          
          # Backend API
          for i in {1..10}; do
            if curl -f http://localhost:8070/health > /dev/null 2>&1; then
              echo "Backend API is healthy"
              break
            elif [ $i -eq 10 ]; then
              echo "Backend API failed to start"
              exit 1
            else
              echo "Waiting for backend API... (attempt $i/10)"
              sleep 10
            fi
          done
          
          # Thesaurus API (built from Dockerfile)
          for i in {1..10}; do
            if curl -f -X POST http://localhost:8002/health -H "Content-Type: application/json" -d '{"ping":"test"}' > /dev/null 2>&1; then
              echo "Thesaurus API is healthy"
              break
            elif [ $i -eq 10 ]; then
              echo "Thesaurus API failed to start"
              echo "Checking thesaurus container logs..."
              docker compose logs thesaurus-api || true
              exit 1
            else
              echo "Waiting for thesaurus API... (attempt $i/10)"
              sleep 20
            fi
          done
          
          # LLM API
          for i in {1..5}; do
            if curl -f http://localhost:8003/health > /dev/null 2>&1; then
              echo "LLM API is healthy"
              break
            elif [ $i -eq 5 ]; then
              echo "LLM API failed to start"
              exit 1
            else
              echo "Waiting for LLM API... (attempt $i/5)"
              sleep 10
            fi
          done
          
          # Test ML API only if not skipped
          if [ "${{ github.event.inputs.skip_services }}" != "true" ]; then
            for i in {1..15}; do
              if curl -f http://localhost:8001/health > /dev/null 2>&1; then
                echo "ML API is healthy"
                break
              elif [ $i -eq 15 ]; then
                echo "ML API failed to start"
                exit 1
              else
                echo "Waiting for ML API... (attempt $i/15)"
                sleep 15
              fi
            done
          fi
          
          # Test Quick Start endpoints (from Install_Local.md)
          echo "Testing Quick Start endpoints..."
          
          # Test Swagger UI
          if curl -f http://localhost:8070/swagger/ > /dev/null 2>&1; then
            echo "Swagger UI is accessible at http://localhost:8070/swagger/"
          else
            echo "Swagger UI is not accessible"
            exit 1
          fi
          
          # Test Directus admin panel
          if curl -f http://localhost:8055 > /dev/null 2>&1; then
            echo "Directus admin panel is accessible at http://localhost:8055/"
          else
            echo "Directus admin panel is not accessible"
            exit 1
          fi
          
          # Test Distractor API docs
          if curl -f http://localhost:8001/docs > /dev/null 2>&1; then
            echo "Distractor API docs are accessible at http://localhost:8001/docs"
          else
            echo "Distractor API docs are not accessible (may be disabled in test)"
          fi
          
          # Test Thesaurus API docs
          if curl -f http://localhost:8002/docs > /dev/null 2>&1; then
            echo "Thesaurus API docs are accessible at http://localhost:8002/docs"
          else
            echo "Thesaurus API docs are not accessible"
            exit 1
          fi
          
          # Test LLM API docs
          if curl -f http://localhost:8003/docs > /dev/null 2>&1; then
            echo "LLM API docs are accessible at http://localhost:8003/docs"
          else
            echo "LLM API docs are not accessible"
            exit 1
          fi
          
          # Test macOS specific considerations
          echo "Testing macOS-specific considerations..."
          
          # Check if ARM64 images are being used on Apple Silicon
          if [[ "$(uname -m)" == "arm64" ]]; then
            echo "Apple Silicon detected - checking for ARM64 images..."
            docker compose images | grep -E "(linux/arm64|arm64)" || echo "No ARM64 images detected"
          fi

      - name: Show service status
        if: always()
        run: |
          echo "📊 Service Status:"
          make status || true
          
          echo "📋 Docker Compose Services:"
          docker compose ps || true
          
          echo "💾 Disk Usage:"
          df -h | head -5

      - name: Show logs on failure
        if: failure()
        run: |
          echo "🔍 Service Logs:"
          docker compose logs --tail=50 || true

      - name: Cleanup
        if: always()
        run: |
          make stop-local || true
          docker system prune -f || true

  # Summary job that depends on all platform tests
  platform-test-summary:
    runs-on: ubuntu-latest
    needs: [test-ubuntu, test-macos, test-windows]
    if: always()
    
    steps:
      - name: Test Results Summary
        run: |
          echo "Platform Testing Results Summary"
          echo "=================================="
          
          # Check Ubuntu results
          if [ "${{ needs.test-ubuntu.result }}" = "success" ]; then
            echo "PASSED: Ubuntu"
          elif [ "${{ needs.test-ubuntu.result }}" = "skipped" ]; then
            echo "SKIPPED: Ubuntu"
          else
            echo "FAILED: Ubuntu"
          fi
          
          # Check macOS results
          if [ "${{ needs.test-macos.result }}" = "success" ]; then
            echo "PASSED: macOS"
          elif [ "${{ needs.test-macos.result }}" = "skipped" ]; then
            echo "SKIPPED: macOS"
          else
            echo "FAILED: macOS"
          fi
          
          # Check Windows results
          if [ "${{ needs.test-windows.result }}" = "success" ]; then
            echo "PASSED: Windows"
          elif [ "${{ needs.test-windows.result }}" = "skipped" ]; then
            echo "SKIPPED: Windows"
          else
            echo "FAILED: Windows"
          fi
          
          # Overall result
          if [ "${{ needs.test-ubuntu.result }}" = "success" ] && [ "${{ needs.test-macos.result }}" = "success" ] && [ "${{ needs.test-windows.result }}" = "success" ]; then
            echo ""
            echo "All platform tests passed!"
            echo "Ready for deployment across all supported platforms"
          else
            echo ""
            echo "Some platform tests failed or were skipped"
            echo "Please check the individual job results above"
          fi
