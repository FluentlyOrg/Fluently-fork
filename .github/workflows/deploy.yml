name: Deploy

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to deploy"
        required: false
        default: "main"
      environment:
        description: "Deployment environment (production/staging)"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - production
          - staging
      rollback:
        description: "Rollback to previous version"
        required: false
        default: false
        type: boolean

jobs:
  # Determine deployment environment
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      domain: ${{ steps.env.outputs.domain }}
      is_rollback: ${{ github.event.inputs.rollback || 'false' }}
    steps:
      - name: Determine environment
        id: env
        run: |
          BRANCH="${{ github.event.inputs.branch || github.ref_name }}"
          ENV_INPUT="${{ github.event.inputs.environment }}"
          
          # Auto-determine environment based on branch if not manually specified
          if [ "$ENV_INPUT" = "auto" ] || [ -z "$ENV_INPUT" ]; then
            if [ "$BRANCH" = "main" ]; then
              ENVIRONMENT="production"
            else
              ENVIRONMENT="staging"
            fi
          else
            ENVIRONMENT="$ENV_INPUT"
          fi
          
          # Set environment-specific variables
          if [ "$ENVIRONMENT" = "production" ]; then
            DOMAIN="fluently-app.ru"
            HOST="${{ secrets.DEPLOY_HOST }}"
            USERNAME="${{ secrets.DEPLOY_USERNAME }}"
            ZEROTIER_IP="${{ secrets.ZEROTIER_IP }}"
          else
            DOMAIN="fluently-app.online"
            HOST="${{ secrets.STAGING_DEPLOY_HOST }}"
            USERNAME="${{ secrets.STAGING_DEPLOY_USERNAME }}"
            ZEROTIER_IP="${{ secrets.STAGING_ZEROTIER_IP }}"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          
          if [ "${{ github.event.inputs.rollback }}" = "true" ]; then
            echo "🔄 Rollback requested for $ENVIRONMENT environment"
          else
            echo "🚀 Deploying branch '$BRANCH' to $ENVIRONMENT environment ($DOMAIN)"
          fi

  # Code quality analysis
  quality-check:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
          cache: true  # Enable Go module caching
          cache-dependency-path: backend/go.sum

      - name: Cache Go dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('backend/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install swag for Go docs generation
        run: |
          echo "📦 Installing swag..."
          go install github.com/swaggo/swag/cmd/swag@latest
          echo "✅ Swag installed to: $(which swag || echo '$HOME/go/bin/swag')"

      - name: Initialize Go module and generate docs
        working-directory: ./backend
        run: |
          # Add Go bin to PATH
          export PATH=$PATH:$HOME/go/bin
          
          # Ensure Go modules are properly initialized
          echo "📦 Ensuring Go dependencies are available..."
          go mod download
          go mod tidy
          
          # Debug: Verify we're in the right place and files exist
          echo "🔍 Current working directory: $(pwd)"
          echo "🔍 Go version: $(go version)"
          echo "🔍 Checking for main.go:"
          test -f cmd/main.go && echo "✅ cmd/main.go exists" || echo "❌ cmd/main.go missing"
          
          # Verify swag is available
          echo "🔍 Checking swag installation:"
          if command -v swag >/dev/null 2>&1; then
            echo "✅ swag found in PATH: $(which swag)"
          elif [ -f "$HOME/go/bin/swag" ]; then
            echo "✅ swag found at: $HOME/go/bin/swag"
          else
            echo "❌ swag not found"
            exit 1
          fi
          
          # Create docs directory if it doesn't exist
          mkdir -p docs
          
          # Generate Swagger documentation with proper directory specification
          echo "📚 Generating API documentation..."
          echo "Current directory: $(pwd)"
          echo "Contents of current directory:"
          ls -la
          echo "Contents of cmd directory:"
          ls -la cmd/
          if command -v swag >/dev/null 2>&1; then
            swag init -g ./cmd/main.go -o ./docs --parseDependency --parseInternal
          else
            $HOME/go/bin/swag init -g ./cmd/main.go -o ./docs --parseDependency --parseInternal
          fi
          
          # Verify docs were generated
          if [ ! -d "docs" ] || [ ! -f "docs/swagger.json" ]; then
            echo "❌ Failed to generate docs properly"
            echo "🔍 Contents of docs directory:"
            ls -la docs/ || echo "docs directory not found"
            exit 1
          fi
          
          echo "✅ Documentation generated successfully"
          echo "📁 Generated files:"
          ls -la docs/

      - name: Start test database
        run: |
          docker compose -f docker-compose.test.yml down --volumes
          docker compose -f docker-compose.test.yml up -d test_db
        
      - name: Wait for DB to become healthy
        run: |
          for i in {1..20}; do
            docker inspect -f '{{json .State.Health.Status}}' fluently_test_db | grep -q healthy && break
            sleep 3
          done
        
      - name: Go tests with coverage
        working-directory: ./backend
        env:
          DB_HOST:     fluently_test_db
          DB_PORT:     5433
          DB_USER:     test_user
          DB_PASSWORD: test_pass
          DB_NAME:     test_db
        run: |
          go test ./... -coverprofile=coverage.out -covermode=atomic
          go tool cover -func=coverage.out
        
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN:  ${{ secrets.SONAR_TOKEN }}
        
      - name: Stop test database & wipe volume
        if: always()
        run: docker compose -f docker-compose.test.yml down --volumes

  deploy:
    needs: [setup]  # Re-enable quality-check dependency
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug values
        run: |
          echo "🔍 Debug Information:"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Domain: ${{ needs.setup.outputs.domain }}"
          echo "Is Rollback: ${{ needs.setup.outputs.is_rollback }}"

      - name: Deploy to ${{ needs.setup.outputs.environment }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.setup.outputs.environment == 'production' && secrets.DEPLOY_HOST || secrets.STAGING_DEPLOY_HOST }}
          username: ${{ needs.setup.outputs.environment == 'production' && secrets.DEPLOY_USERNAME || secrets.STAGING_DEPLOY_USERNAME }}
          key: ${{ needs.setup.outputs.environment == 'production' && secrets.DEPLOY_SSH_KEY || secrets.STAGING_DEPLOY_SSH_KEY }}
          timeout: 20m
          command_timeout: 20m
          script: |
            set -e
            
            BRANCH="${{ github.event.inputs.branch || github.ref_name }}"
            ENVIRONMENT="${{ needs.setup.outputs.environment }}"
            DOMAIN="${{ needs.setup.outputs.domain }}"
            IS_ROLLBACK="${{ needs.setup.outputs.is_rollback }}"
            
            echo "🔄 Starting deployment process for $ENVIRONMENT environment"
            echo "🌐 Domain: $DOMAIN"
            
            # Navigate to project directory and set environment variables
            if [ "$ENVIRONMENT" = "production" ]; then
              cd /home/deploy/Fluently-fork
              export ZEROTIER_IP="${{ secrets.ZEROTIER_IP }}"
              BACKUP_DIR="/home/deploy/backups"
              PROJECT_DIR="/home/deploy/Fluently-fork"
            else
              cd /home/deploy-staging/Fluently-fork
              export ZEROTIER_IP="${{ secrets.STAGING_ZEROTIER_IP }}"
              BACKUP_DIR="/home/deploy-staging/backups"
              PROJECT_DIR="/home/deploy-staging/Fluently-fork"
            fi
            
            # Create backup directory if it doesn't exist
            mkdir -p "$BACKUP_DIR"
            
            # Function to perform health checks
            check_health() {
              echo "🏥 Performing health checks..."
              
              # Wait for services to start
              sleep 10
              
              # Check if backend is healthy
              echo "Checking backend health..."
              for i in {1..10}; do
                if curl -f "http://localhost:8070/health" >/dev/null 2>&1; then
                  echo "✅ Backend is healthy"
                  break
                elif [ $i -eq 10 ]; then
                  echo "❌ Backend health check failed after 10 attempts"
                  return 1
                else
                  echo "⏳ Waiting for backend... (attempt $i/10)"
                  sleep 10
                fi
              done
              
              # Check if ML API is healthy (takes 2-3 minutes to initialize)
              echo "Checking ML API health..."
              for i in {1..20}; do
                if docker compose exec -T ml-api curl -f "http://localhost:8001/health" >/dev/null 2>&1; then
                  echo "✅ ML API is healthy"
                  break
                elif [ $i -eq 20 ]; then
                  echo "❌ ML API health check failed after 20 attempts"
                  return 1
                else
                  echo "⏳ Waiting for ML API... (attempt $i/20)"
                  sleep 15
                fi
              done
              
              # Check if PostgreSQL is healthy
              echo "Checking PostgreSQL health..."
              if docker compose exec -T postgres pg_isready -U ${DB_USER:-postgres} >/dev/null 2>&1; then
                echo "✅ PostgreSQL is healthy"
              else
                echo "❌ PostgreSQL health check failed"
                return 1
              fi
              
              # Check if nginx is responding
              echo "Checking nginx health..."
              for i in {1..5}; do
                if curl -f -s "http://localhost" >/dev/null 2>&1 || curl -f -s "http://127.0.0.1" >/dev/null 2>&1; then
                  echo "✅ Nginx is healthy"
                  break
                elif [ $i -eq 5 ]; then
                  echo "❌ Nginx health check failed after 5 attempts"
                  # Try to get more info about what's wrong
                  echo "🔍 Debugging nginx status:"
                  docker compose ps nginx || true
                  docker compose logs --tail=20 nginx || true
                  return 1
                else
                  echo "⏳ Waiting for nginx... (attempt $i/5)"
                  sleep 5
                fi
              done
              
              # Check if telegram bot is healthy
              echo "Checking telegram bot health..."
              for i in {1..3}; do
                if docker compose ps telegram-bot | grep -q "Up"; then
                  echo "✅ Telegram bot is running"
                  # Check if bot can connect to Telegram API
                  if docker compose logs telegram-bot | grep -q "Successfully connected to Redis"; then
                    echo "✅ Telegram bot connected to Redis"
                  fi
                  if docker compose logs telegram-bot | grep -q "telegram: Not Found (404)"; then
                    echo "❌ Telegram bot has invalid token (404 error)"
                    echo "🔍 Bot logs:"
                    docker compose logs --tail=10 telegram-bot || true
                    return 1
                  fi
                  break
                elif [ $i -eq 3 ]; then
                  echo "❌ Telegram bot health check failed"
                  echo "🔍 Bot logs:"
                  docker compose logs --tail=10 telegram-bot || true
                  return 1
                else
                  echo "⏳ Waiting for telegram bot... (attempt $i/3)"
                  sleep 5
                fi
              done
              
              echo "🎉 All health checks passed!"
              return 0
            }
            
            # Function to rollback
            rollback() {
              echo "🔄 Rolling back to previous version..."
              
              # Find the latest backup
              LATEST_BACKUP=$(ls -t "$BACKUP_DIR"/fluently-backup-*.tar.gz 2>/dev/null | head -1)
              
              if [ -z "$LATEST_BACKUP" ]; then
                echo "❌ No backup found for rollback!"
                return 1
              fi
              
              echo "📦 Found backup: $LATEST_BACKUP"
              
              # Stop current services
              docker compose down --remove-orphans || true
              
              # Create rollback backup of current state
              ROLLBACK_BACKUP="$BACKUP_DIR/fluently-rollback-backup-$(date +%Y%m%d-%H%M%S).tar.gz"
              tar -czf "$ROLLBACK_BACKUP" --exclude=node_modules --exclude=.git . || echo "⚠️ Rollback backup failed"
              
              # Restore from backup
              tar -xzf "$LATEST_BACKUP" --exclude=node_modules --exclude=.git .
              
              # Start services
              docker compose up -d --force-recreate
              
              # Verify rollback
              if check_health; then
                echo "✅ Rollback completed successfully!"
                return 0
              else
                echo "❌ Rollback failed health checks!"
                return 1
              fi
            }
            
            # Handle rollback request
            if [ "$IS_ROLLBACK" = "true" ]; then
              rollback
              exit $?
            fi
            
            # Backup current state (only for production)
            if [ "$ENVIRONMENT" = "production" ]; then
              echo "📦 Creating backup..."
              BACKUP_FILE="$BACKUP_DIR/fluently-backup-$(date +%Y%m%d-%H%M%S).tar.gz"
              tar -czf "$BACKUP_FILE" --exclude=node_modules --exclude=.git . || echo "⚠️ Backup failed but continuing..."
              
              # Keep only last 5 backups
              ls -t "$BACKUP_DIR"/fluently-backup-*.tar.gz 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
            fi
            
            # Store current state for potential rollback
            CURRENT_STATE_BACKUP="$BACKUP_DIR/fluently-current-state-$(date +%Y%m%d-%H%M%S).tar.gz"
            tar -czf "$CURRENT_STATE_BACKUP" --exclude=node_modules --exclude=.git . || echo "⚠️ Current state backup failed"
            
            # Update code
            echo "📥 Updating code..."

            # Fix Git ownership issue
            git config --global --add safe.directory $(pwd)

            # Restore any local changes before pulling
            git restore .

            git fetch origin
            git checkout $BRANCH
            git pull origin $BRANCH

            # Create main .env file from root .env.example if it doesn't exist
            if [ ! -f ".env" ]; then
              echo "📝 Creating main .env file from root .env.example..."
              cp .env.example .env
            fi

            # Create backend/.env for backward compatibility if it doesn't exist
            if [ ! -f "backend/.env" ]; then
              echo "📝 Creating backend/.env file (copy of root .env)..."
              cp .env backend/.env
            fi

            # Update environment variables based on deployment target
            echo "⚙️ Updating environment configuration..."

            # Update ZeroTier IP in both .env files
            if grep -q "ZEROTIER_IP=" .env; then
              sed -i "s/ZEROTIER_IP=.*/ZEROTIER_IP=$ZEROTIER_IP/" .env
            else
              echo "ZEROTIER_IP=$ZEROTIER_IP" >> .env
            fi
            
            # Also update backend/.env for backward compatibility
            if grep -q "ZEROTIER_IP=" backend/.env; then
              sed -i "s/ZEROTIER_IP=.*/ZEROTIER_IP=$ZEROTIER_IP/" backend/.env
            else
              echo "ZEROTIER_IP=$ZEROTIER_IP" >> backend/.env
            fi

            # Update PUBLIC_URL in both .env files
            sed -i "s|PUBLIC_URL=.*|PUBLIC_URL=https://$DOMAIN|g" .env
            sed -i "s|PUBLIC_URL=.*|PUBLIC_URL=https://$DOMAIN|g" backend/.env

            # Add telegram bot environment variables if they don't exist
            echo "🔧 Setting up Telegram bot configuration..."
            if [ "$ENVIRONMENT" = "production" ]; then
              BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
              WEBHOOK_SECRET="${{ secrets.WEBHOOK_SECRET }}"
              echo "📝 Using production bot credentials"
            else
              BOT_TOKEN="${{ secrets.STAGING_TELEGRAM_BOT_TOKEN }}"
              WEBHOOK_SECRET="${{ secrets.STAGING_WEBHOOK_SECRET }}"
              echo "📝 Using staging bot credentials"
            fi
            
            # Debug: Check if secrets are provided (without printing actual values)
            if [ -z "$BOT_TOKEN" ]; then
              echo "⚠️ WARNING: BOT_TOKEN is empty for $ENVIRONMENT environment!"
              echo "Please set the following GitHub secret:"
              if [ "$ENVIRONMENT" = "production" ]; then
                echo "   TELEGRAM_BOT_TOKEN"
              else
                echo "   STAGING_TELEGRAM_BOT_TOKEN"
              fi
            else
              echo "✅ BOT_TOKEN is provided (length: ${#BOT_TOKEN} characters)"
            fi
            
            if [ -z "$WEBHOOK_SECRET" ]; then
              echo "⚠️ WARNING: WEBHOOK_SECRET is empty for $ENVIRONMENT environment!"
              echo "Please set the following GitHub secret:"
              if [ "$ENVIRONMENT" = "production" ]; then
                echo "   WEBHOOK_SECRET"
              else
                echo "   STAGING_WEBHOOK_SECRET"
              fi
            else
              echo "✅ WEBHOOK_SECRET is provided"
            fi
            
            # Set telegram bot configuration in root .env
            if [ ! -z "$BOT_TOKEN" ]; then
              if grep -q "BOT_TOKEN=" .env; then
                sed -i "s/BOT_TOKEN=.*/BOT_TOKEN=$BOT_TOKEN/" .env
              else
                echo "BOT_TOKEN=$BOT_TOKEN" >> .env
              fi
              echo "✅ BOT_TOKEN set in .env file"
            else
              echo "❌ Skipping BOT_TOKEN setup (empty value)"
            fi
            
            if [ ! -z "$WEBHOOK_SECRET" ]; then
              if grep -q "WEBHOOK_SECRET=" .env; then
                sed -i "s/WEBHOOK_SECRET=.*/WEBHOOK_SECRET=$WEBHOOK_SECRET/" .env
              else
                echo "WEBHOOK_SECRET=$WEBHOOK_SECRET" >> .env
              fi
              echo "✅ WEBHOOK_SECRET set in .env file"
            else
              echo "❌ Skipping WEBHOOK_SECRET setup (empty value)"
            fi
            
            # Set webhook URL
            if grep -q "WEBHOOK_URL=" .env; then
              sed -i "s|WEBHOOK_URL=.*|WEBHOOK_URL=https://$DOMAIN/webhook|g" .env
            else
              echo "WEBHOOK_URL=https://$DOMAIN/webhook" >> .env
            fi
            
            # Set Redis configuration for Docker network
            if grep -q "REDIS_ADDR=" .env; then
              sed -i "s|REDIS_ADDR=.*|REDIS_ADDR=redis:6379|g" .env
            else
              echo "REDIS_ADDR=redis:6379" >> .env
            fi

            echo "📋 Main .env file ready for docker-compose..."
            
            # Debug: Show telegram bot configuration (without sensitive values)
            echo "🔍 Telegram bot configuration in .env:"
            echo "BOT_TOKEN: $(grep "BOT_TOKEN=" .env | sed 's/BOT_TOKEN=.*/BOT_TOKEN=[HIDDEN]/' || echo 'Not set')"
            echo "WEBHOOK_SECRET: $(grep "WEBHOOK_SECRET=" .env | sed 's/WEBHOOK_SECRET=.*/WEBHOOK_SECRET=[HIDDEN]/' || echo 'Not set')"
            echo "WEBHOOK_URL: $(grep "WEBHOOK_URL=" .env || echo 'Not set')"
            echo "REDIS_ADDR: $(grep "REDIS_ADDR=" .env || echo 'Not set')"

            # Set Swagger host for the environment
            if [ "$ENVIRONMENT" = "production" ]; then
              export SWAGGER_HOST="${{ secrets.ZEROTIER_IP }}:8070"
            else
              export SWAGGER_HOST="${{ secrets.STAGING_ZEROTIER_IP }}:8070"
            fi
            
            echo "🔧 Setting up environment variables..."
            echo "SWAGGER_HOST=$SWAGGER_HOST"
            

            # Generate nginx config from template
            echo "🔧 Generating nginx configuration from template..."
            if [ "$ENVIRONMENT" = "production" ]; then
              export CERT_NAME="fluently-app-ru"
            else
              export CERT_NAME="fluently-app-online"
            fi

            export DOMAIN
            # Specify which variables to substitute, leaving nginx variables untouched
            envsubst '${DOMAIN} ${CERT_NAME}' < backend/nginx-container/nginx.conf.template > backend/nginx-container/default.conf

            echo "Generated nginx config for $DOMAIN with cert $CERT_NAME"

            # Generate environment-specific backup scripts
            echo "🔧 Generating environment-specific backup scripts..."
            export BACKUP_DIR
            export ENVIRONMENT
            export PROJECT_DIR
            
            # Generate backup script
            envsubst '${BACKUP_DIR} ${ENVIRONMENT}' < scripts/backup_volumes.sh.template > scripts/backup_volumes.sh
            chmod +x scripts/backup_volumes.sh
            
            # Generate restore script  
            envsubst '${BACKUP_DIR} ${ENVIRONMENT}' < scripts/restore_volumes.sh.template > scripts/restore_volumes.sh
            chmod +x scripts/restore_volumes.sh
            
            # Generate migration script
            envsubst '${BACKUP_DIR} ${ENVIRONMENT}' < scripts/migrate_to_external_volumes.sh.template > scripts/migrate_to_external_volumes.sh
            chmod +x scripts/migrate_to_external_volumes.sh
            
            # Generate cron setup script
            envsubst '${BACKUP_DIR} ${ENVIRONMENT} ${PROJECT_DIR}' < scripts/setup_cron.sh.template > scripts/setup_cron.sh
            chmod +x scripts/setup_cron.sh
            
            # Generate backup operations script
            envsubst '${BACKUP_DIR} ${ENVIRONMENT}' < scripts/backup_ops.sh.template > scripts/backup_ops.sh
            chmod +x scripts/backup_ops.sh
            
            echo "✅ Generated environment-specific scripts for $ENVIRONMENT"

            echo "🐳 Starting Docker containers..."
            # Stop services first
            docker compose down --remove-orphans || true

            # Clean up Docker networks to prevent conflicts
            echo "🧹 Cleaning up Docker networks..."
            
            # Remove project-specific networks if they exist
            docker network rm fluently-fork_fluently_network 2>/dev/null || true
            docker network rm fluently_network 2>/dev/null || true
            
            # Prune unused networks
            docker network prune -f || true
            
            echo "✅ Network cleanup completed"

            # Build with progress output and timeout handling
            echo "🔨 Building Docker images with optimized caching..."
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1
            
            # Pre-warm Go module cache for faster builds
            echo "🚀 Pre-warming Go build cache..."
            docker build --target builder \
              --build-arg BUILDKIT_INLINE_CACHE=1 \
              --cache-from fluently-fork-backend:cache \
              --cache-from fluently-fork-telegram-bot:cache \
              -t temp-go-cache backend/ || echo "⚠️ Cache warm-up failed, continuing..."
            
            # Build ML API separately first (it takes the longest) with timeout
            echo "🤖 Building ML API (this may take several minutes)..."
            timeout 20m docker compose build --parallel ml-api || {
              echo "❌ ML API build timed out after 20 minutes"
              exit 1
            }
            
            # Build remaining services in parallel with reduced timeout
            echo "🔨 Building remaining services in parallel..."
            timeout 10m docker compose build --parallel || {
              echo "❌ Services build timed out after 10 minutes"
              exit 1
            }

            # Start services with force recreate
            docker compose up -d --force-recreate

            # Perform health checks
            if check_health; then
              echo "🎉 Deployment completed successfully!"
              echo "🌐 Application available at: https://$DOMAIN"
              
              # Show running containers
              echo "📋 Running containers:"
              docker compose ps
              
              # Show telegram bot setup instructions
              echo ""
              echo "🤖 Telegram Bot Setup Instructions:"
              echo "If the bot token is set correctly, run this command to set up the webhook:"
              echo ""
              echo "curl -X POST \"https://api.telegram.org/bot\$BOT_TOKEN/setWebhook\" \\"
              echo "     -H \"Content-Type: application/json\" \\"
              echo "     -d '{\"url\": \"https://$DOMAIN/webhook\"}'"
              echo ""
              echo "Replace \$BOT_TOKEN with your actual bot token from the GitHub secrets."
              echo "You can test the webhook by sending a message to your bot."
              echo ""
              
              # Cleanup old images (keep last 3)
              echo "🧹 Cleaning up old Docker images..."
              docker image prune -f || true
              
              # Remove current state backup since deployment was successful
              rm -f "$CURRENT_STATE_BACKUP" || true
              
            else
              echo "❌ Deployment failed health checks! Starting rollback..."
              
              # Restore from current state backup
              echo "🔄 Restoring previous state..."
              docker compose down --remove-orphans || true
              tar -xzf "$CURRENT_STATE_BACKUP" --exclude=node_modules --exclude=.git . || echo "⚠️ Restore failed"
              docker compose up -d --force-recreate
              
              # Cleanup failed backup
              rm -f "$CURRENT_STATE_BACKUP" || true
              
              echo "❌ Deployment failed and rollback attempted"
              exit 1
            fi

            # Final verification: Ensure bot token is set before building
            if ! grep -q "BOT_TOKEN=.*[^[:space:]]" .env; then
              echo ""
              echo "❌ CRITICAL ERROR: BOT_TOKEN is not properly set in .env file!"
              echo ""
              echo "🔧 To fix this issue:"
              echo "1. Go to GitHub repository Settings > Secrets and variables > Actions"
              echo "2. Add the following secrets:"
              if [ "$ENVIRONMENT" = "production" ]; then
                echo "   - TELEGRAM_BOT_TOKEN (get from @BotFather on Telegram)"
                echo "   - WEBHOOK_SECRET (random secure string)"
              else
                echo "   - STAGING_TELEGRAM_BOT_TOKEN (get from @BotFather on Telegram)"
                echo "   - STAGING_WEBHOOK_SECRET (random secure string)"
              fi
              echo ""
              echo "3. To create a bot token:"
              echo "   - Message @BotFather on Telegram"
              echo "   - Use /newbot command"
              echo "   - Follow instructions to create your bot"
              echo "   - Copy the token (format: 123456789:ABCdefGHIjklMNOpqrsTUVwxyz)"
              echo ""
              echo "🚫 Deployment will continue but telegram bot will not work!"
              echo ""
            fi

